using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/*
 * 
 * Every shape being streamed can either be with no owner, or with one owner
 * Clients subscribe to channels and send and receive messages 
 * Message keeps information about changed shape
 * Local player applies message to local scene
 * Token owner sends update messages when it changes owned shape
 * Badge is just ordinary shape, it has token owner too 
 * 
 * 
 * Update message types can be: Create new, Delete existing, Existing changed
 * 
 * Dependencies
 *      Clusters, badges, and links are connected shapes. Text, free form, line are simple shapes. 
 *      
 *      Clusters depend on badges in it
 *      Links depend on its endpoints (clusters and badges)
 * 
 *      When badge changes:
 *          update clusters
 *          update links
 *      When link changes (only remove or create)
 *          update link
 * 
 * Client.Player 
 *     Receives messages about simple shapes and badges (generated by owner-clients) and
 *     messages about cluster changes (cluster shape, existence, link existence)
 * 
 *     If message changes simple shape, apply the change.
 *     Else (message changes complex shape): 
 *          Update the badge 
 *          Update dependencies of the badge (no broadcast of post effects)
 * 
 * Client.Sender 
 *     Sends messages about owned simple shapes and badges to photon. 
 * 
 * 
 * Photon
 *      Handles cluster engine. Receives badge messages and recomputes cluster configuration. 
 *      Sends updated cluster configuration back to clients. Generates link messages when required.
 * 
 *          Badge added: 
 *             If it falls into cluster, update cluster and broadcast 1. Badge added. 2. Updated cluster.
 *          Badge removed:
 *             Broadcast badge removed
 *             If it was in cluster, rebuid cluster and broadcast updated cluster
 *             If it had links, remove all links and broadcast link deletion
 *          Badge moved:
 *             Broadcast badge moved
 *             If it was in cluster and now left it, rebuid cluster and broadcast updated cluster 
 *             If it joined new cluster, rebuild it and broadcast updated cluster 
 *             If badge has links, move them and broadcast moved links 
 * 
 *          Cluster created:
 *              Broadcast cluster created
 *          Cluster moved:
 *              Broadcast moved cluster and moved badges 
 * 
 *          Link added:
 *              Broadcast new link 
 *          Link removed:
 *              Broadcast link removed
 *           
 *          Simple shape created: 
 *              Broadcast shape created
 *          Simple shape moved:
 *              Broadcast simpe shape moved
 *          Simple deleted:
 *               Broadcast simpe shape deleted
 *               
           
 * Messaging 
 *      Request: Lock shape (become owner) request. 
 *      Parameters: id of shape 
 *      Response: success or failure
 * 
 *      Request: Create shape request.  
 *      Parameters: Applies to badge, line, text, link, free form
 *      
 *      Request: Delete shape request. 
 *      Parameters: Applies to badge, line, text, link, free form
 *      Response: success of failure (owned by another person?)
 *      
 *      Request: Move shape request.
 *      Parameters: badge, line, text, link, free form, cluster
 *          
 *      
 * Notifications: 
 *      Shape created
 *      Parameters: shape code, initial info
 *      
 *      Shape deleted
 *      Parameters: shape id
 *      
 *      Shape moved
 *      Parameters: shape id, new position      
 *      
 * 
 * Initial loading format:
 *      Current DB format
 *      
 * 
 * 1. User initiates input
 * 2. Apply local input 
 * 3. Read shape state and send to photon
 * 4. Photon broadcasts normalized state
 * 5. Other clients play update
 * 
 * 
 * Cursors
 *  each shape can be free or can have one cursor.
    any user can lock only one shape at a time. 
 * Cursor operations
 *  set user cursor to shape 
 *  unset all cursors from shape 
 * 
 * 
 * Shape creation
 *  Initiator sends creation request
 *  Initiator creates local shape, no expectation. Also initiator sets user cursor to newly created shape.
 *  Photon broadcasts shape creation
 *  Other clients create new shape and set owner
 * 
*/

namespace Discussions.VectorEditor
{
    internal class Streaming
    {
    }
}